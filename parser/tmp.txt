/**
 * Generated parser in Rust.
 *
 * ./bin/syntax -g examples/calc-ast.rs.g -m lalr1 -o lib.rs
 *
 * use syntax::Parser;
 *
 * let parser = Parser::new();
 *
 * let ast = parser.parse("2 + 2 * 2");
 */

%lex

%%

\s+         /* skip whitespace */ return "";

\d+         return "NUMBER";

"+"         return "+";
"*"         return "*";

"("         return "(";
")"         return ")";

/lex

%left +
%left *

%{

/**
 * Recursive generic `Node` enum structure.
 */
#[derive(Debug)]
pub enum Node {

    Literal(i32),

    Binary {
        op: &'static str,
        left: Box<Node>,
        right: Box<Node>,
    },
}
/**
 * Final result type returned from `parse` method call.
 */
pub type TResult = Node;
/**
 * Hook executed on parse begin.
 */
fn on_parse_begin(_parser: &mut Parser, string: &'static str) {
    println!("Parsing: {:?}", string);
}

/**
 * Hook executed on parse end.
 */
fn on_parse_end(_parser: &mut Parser, result: &TResult) {
    println!("Parsed: {:?}", result);
}

%}

%%

Expr
    : Expr + Expr {

        // Types of used args ($1, $2, ...), and return type:
        |$1: Node; $3: Node| -> Node;

        $$ = Node::Binary {
            op: "+",
            left: Box::new($1),
            right: Box::new($3),
        }
    }

    | Expr * Expr {

        |$1: Node; $3: Node| -> Node;

        $$ = Node::Binary {
            op: "*",
            left: Box::new($1),
            right: Box::new($3),
        }
    }

    | ( Expr ) {

        // No need to define argument types, since we don't do any
        // operations here, and just propagate $2 further.
        $$ = $2;
    }
    | NUMBER {
        || -> Node;
        let n = yytext.parse::<i32>().unwrap();
        $$ = Node::Literal(n);
    };



    | Call {
        |$1: Sem| -> Sem;
        $$ = $1;
    }
    | Constant {
        |$1: Sem| -> Sem;
        $$ = $1;
    }
| Expr EQUAL Expr {
        $$.expr = new Tree.Binary(Tree.EQ, $1.expr, $3.expr, $2.loc);
    }
    | Expr NOT_EQUAL Expr {
        $$.expr = new Tree.Binary(Tree.NE, $1.expr, $3.expr, $2.loc);
    }
    | Expr '<' Expr {
         $$.expr = new Tree.Binary(Tree.LT, $1.expr, $3.expr, $2.loc);
     }
    | Expr '>' Expr {
         $$.expr = new Tree.Binary(Tree.GT, $1.expr, $3.expr, $2.loc);
    }
    | Expr LESS_EQUAL Expr {
        $$.expr = new Tree.Binary(Tree.LE, $1.expr, $3.expr, $2.loc);
    }
    | Expr GREATER_EQUAL Expr {
        $$.expr = new Tree.Binary(Tree.GE, $1.expr, $3.expr, $2.loc);
    }
    | Expr AND Expr {
                $$.expr = new Tree.Binary(Tree.AND, $1.expr, $3.expr, $2.loc);
    }
    | Expr OR Expr {
        $$.expr = new Tree.Binary(Tree.OR, $1.expr, $3.expr, $2.loc);
    }
    | Expr REPEAT Expr {
        $$.expr = new Tree.Binary(Tree.REPEAT, $1.expr, $3.expr, $2.loc);
    }
    | Expr CONCAT Expr {
        $$.expr = new Tree.Binary(Tree.CONCAT, $1.expr, $3.expr, $2.loc);
    }
    | Expr '[' Expr ':' Expr ']' {
        $$.expr = new Tree.RangeExpr($1.expr, $3.expr, $5.expr, $2.loc);
    }
    | Expr '[' Expr ']' DEFAULT Expr {
        $$.expr = new Tree.DefaultExpr($1.expr, $3.expr, $6.expr, $2.loc);
    }
    | '[' Expr FOR IDENTIFIER IN Expr ']' {
        $$.expr = new Tree.ComprehensionExpr($2.expr, $4.ident, $6.expr, $1.loc);
    }
    | '[' Expr FOR IDENTIFIER IN Expr IF Expr ']' {
        $$.expr = new Tree.ComprehensionExpr($2.expr, $4.ident, $6.expr, $8.expr, $1.loc);
    }
    |'(' Expr ')' {
        $$ = $2;
    }
    | '-' Expr %prec UMINUS {
        $$.expr = new Tree.Unary(Tree.NEG, $2.expr, $1.loc);
    }
    | '!' Expr {
        $$.expr = new Tree.Unary(Tree.NOT, $2.expr, $1.loc);
    }
    | READ_INTEGER '(' ')' {
        $$.expr = new Tree.ReadIntExpr($1.loc);
    }
    | READ_LINE '(' ')' {
        $$.expr = new Tree.ReadLineExpr($1.loc);
    }
    | THIS {
        $$.expr = new Tree.ThisExpr($1.loc);
    }
    | NEW IDENTIFIER '(' ')' {
        $$.expr = new Tree.NewClass($2.ident, $1.loc);
    }
    | NEW Type '[' Expr ']' {
        $$.expr = new Tree.NewArray($2.type, $4.expr, $1.loc);
    }
    | INSTANCEOF '(' Expr ',' IDENTIFIER ')' {
        $$.expr = new Tree.TypeTest($3.expr, $5.ident, $1.loc);
    }
    | '(' CLASS IDENTIFIER ')' Expr {
        $$.expr = new Tree.TypeCast($3.ident, $5.expr, $5.loc);
    }